package RichStar

/**
 * Created by IntelliJ IDEA.
 * User: mononofu
 * Date: 7/2/11
 * Time: 9:29 PM
 * To change this template use File | Settings | File Templates.
 */

import Helper.Helper._
import models.Star

// listed in order of brightness
object StarType extends Enumeration {
  type StarType = Value
  val ClassO = Value("Class O") //  0.05%
  val ClassB = Value("Class B") //  0.125%
  val ClassA = Value("Class A") //  0.625%
  val ClassF = Value("Class F") //  3%        white
  val ClassG = Value("Class G") //  7.7%      our sun
  val ClassK = Value("Class K") // 12.5%      suited for life
  val ClassM = Value("Class M") // 76%        red dwarfs and giants
  val BlackHole = Value("Black hole") // not autogenerated
  // values from Wikipedia

  implicit def toRichStar(star: Star) = new RichStar(star.mass, star.orbitRadius, star.orbitEccentricity)

  // self-devised formula
  def determineStarMass() = {
    rnd.nextGaussian() match {
      case p if p < -0.4 => math.abs(nextGaussian(0.5, 0.3))
      case p          => math.abs(nextGaussian (1.5, 0.5))
    }
  }

  // from GURPS space p102
  def determineStarAge() = {      // in years
    (1e9 * (rnd.nextGaussian() match {
      case p if p < -2.33 => 0.0
      case p if p < -1.34 => rnd.nextDouble() * 2.0
      case p if p < 0     => 2.0 + rnd.nextDouble() * 3.6
      case p if p < 1.34  => 5.6 + rnd.nextDouble() * 3.6
      case p if p < 2.33  => 8.0 + rnd.nextDouble() * 3.6
      case p              => 10. + rnd.nextDouble() * 3.6
    } )).toLong
  }


  // from GURPS space p105
  def determineOrbitRadius() = {
    (roll3d6() match {
      case p if p <=  6 =>  0.05
      case p if p <=  9 =>  0.5
      case p if p <= 11 =>  2.0
      case p if p <= 14 => 10.0
      case p            => 50.0
    }) * roll2d6 * 1.5e8 toLong // convert AU to km
  }

  // from GURPS space p105
  def determineOrbitEccentricity(orbitRadius: Long) = {
    (roll3d6() + (orbitRadius match { // fuzy matching  since we use doubles here
      case p if p <= 1e8  => -6   // very close radius
      case p if p <= 1e9  => -4   // close
      case p if p <= 1e10 => -2   // moderate
      case _              =>  0   // everything else
    })) match {
      case p if p <=  3 => 0.0
      case 4            => 0.1
      case 5            => 0.2
      case 6            => 0.3
      case p if p <=  8 => 0.4
      case p if p <= 11 => 0.5
      case p if p <= 13 => 0.6
      case p if p <= 15 => 0.7
      case 16           => 0.8
      case 17           => 0.9
      case _            => 0.95
    }
  }

  
}

case class RichStar(mass: Double, orbitRadius: Long, orbitEcc: Double) {
  // mass is always in sun-masses
  private val sunRadius = 7e5
  val sunLuminosity = 3.433532092185628E26
  val boltzmannContstant = 5.67e-8
  import StarType._

  def mainSequenceLifetime = 1e10 * math.pow(mass, -2.5)
  def subgiantLifetime = mainSequenceLifetime * 0.16
  def giantLifetime = mainSequenceLifetime * 0.1

  def luminosity = {
    mass match {
      case p if p < 0.43 => 0.23 * math.pow(mass, 2.3) * sunLuminosity
      case p if p < 2    =>        math.pow(mass, 4)   * sunLuminosity
      case p if p < 20   => 1.5  * math.pow(mass, 3.5) * sunLuminosity
      case p             =>        mass                * sunLuminosity
    }
  }

  def starType = {
      temperature match {
        case t if t > 30000 => ClassO
        case t if t > 10000 => ClassB
        case t if t >  7600 => ClassA
        case t if t >  6000 => ClassF
        case t if t >  5300 => ClassG
        case t if t >  3900 => ClassK
        case t => ClassM
      }
    }

  def radius = {
    mass match {
      case p if p < 2  => math.pow(mass, 0.9)  * sunRadius
      case p if p < 20 => math.pow(mass, 0.79) * sunRadius
      case p           => math.pow(mass, 0.5)  * sunRadius
    }
  }

  def color = {
    starType match {
      case ClassO => 0xffeef7ff
      case ClassB => 0xffdce3ff
      case ClassA => 0xffe6ffff
      case ClassF => 0xffffffdd
      case ClassG => 0xffffffc7
      case ClassK => 0xfffff69d
      case ClassM => 0xffffdea1
      case BlackHole => 0xff000000
    }
  }

  def temperature = math.pow(luminosity / (4 * math.Pi * math.pow(radius, 2) * boltzmannContstant ), 0.25).toInt

  def getStarLuminosity(temperature: Double, radius: Double) = 4 * math.Pi * math.pow(radius * 1000.0, 2) * math.pow(temperature, 4) * boltzmannContstant

  // values important for planets:

  def minSeperation = (1 - orbitEcc) * orbitRadius
  def maxSeperation = (1 + orbitEcc) * orbitRadius

  // all in AU
  def innerLimitRadius = math.max(0.1 * mass, 0.01 * math.sqrt(luminosity / sunLuminosity))
  def outerLimitRadius = 40. * mass
  def snowLine = 4.85 * math.sqrt(luminosity / sunLuminosity)

}